# 单例模式or工厂模式  
相同点:
1. 都是设计模式中的创建型模式，**用于封装和管理对象的创建**。
2. 都可以提高代码的可维护性和可复用性。

不同点: 
1. 目的不同：``单例模式``的目的是**创建唯一的对象实例**，而``工厂模式``的目的是**创建多种类型**的对象。
2. 实现方式不同：单例模式通常通过一个静态方法返回唯一实例，而工厂模式通过多个工厂方法或类来创建不同类型的对象。*(下面还会详细分析)*
3. 应用场景不同：单例模式适用于全局资源共享，如**配置管理类**；工厂模式适用于创建复杂对象，特别是当一个系统需要独立于其产品的创建、组合和表示时。
4. 控制粒度不同：单例模式控制的是实例的数量（只有一个），工厂模式控制的是创建过程，允许**多个**实例存在。

## 详细分析  
### 单例模式  

在这段安卓开发代码中,为了实现在系统文件中选取图片后,给下一页(展示图片页)提供照片而用到了**数据运输船**``DataService类``,其一次只需定义一个的特性而用到了**单例模式**

```java
 if (requestCode == CODE_AB) {
            try {
                //data.getdata 获取回调函数参数 IntentData的数据
                //返回值为url，因此需要下面的代码来根据url在设备中检索
                mBitmap = MediaStore.Images.Media.getBitmap(this.getContentResolver(), data.getData());

                //以上代码为从系统文件中获取目标图片


                //用DataService的内部函数静态函数 getInstance 使用单例模式
                DataService instance = DataService.getInstance();
                instance.setmBitmap(mBitmap);


                startActivity(Open_activity);  //启动下一页

```
其中,``getInstance()``就是为单例模式服务的公用函数接口,用于让外部在需要DataService实例的时候无法在外部创建,而通过``getIstance()``来创建.  

```java
 public static DataService getInstance() {
        if (dataService == null) {
            synchronized (DataService.class) {
                if (dataService == null) {
                    dataService = new DataService();
                }
                //如果dataService在之前未被创建,那就创建
            }
        }
        return dataService;  //创建完成,返回实例
    }
```

那么,单例模式的类初始化部分应该如何设置?**有无构造函数?**  
```java
public class DataService {

    public  Bitmap mBitmap;


    private static DataService dataService;  
    //*在内部就声明了一个实例dataService,注意不是构造函数





    //接下来的部分就是为了实现数据运输船的功能

    //成员函数1,负责给数据载体Bitmap接收数据
    public Bitmap getmBitmap(){
        return mBitmap;
    }
    //成员函数2,负责给bitmap传出数据
    public void setmBitmap(Bitmap bitmap){
        this.mBitmap = bitmap;
    }
```
### 工厂模式(factory)  
以下运用了spring的**Ioc特性**来实现的``工厂模式``,使用的是**静态工厂类**的方法,`工厂类`本身不需要**构造**.

先看看,工厂模式中用**工厂类**生产的产品(``RollDoge类``)
```java
public class RollDoge {
    private Integer id;
    private String name;
    private Integer RollNuM;

    public RollDoge(Integer id, String name, Integer RollNUM){
        this.RollNuM = RollNUM;
        this.id = id;
        this.name = name;
    }
}
```

工厂模式中的"工厂"
```java
public class RolldogeFact {
    private static Map<Integer, RollDoge> RDproduce;
    static {
        RDproduce = new HashMap<>();
        RDproduce.put(1,new RollDoge(1,"DAlusensei",0xffff));
        RDproduce.put(2,new RollDoge(2,"DazhuSensi",999));
    }

    public static RollDoge getRDresult(Integer num){
        return RDproduce.get(num);  
        //可在外部调用getRDresult函数来获取产品
        //这点就跟单例模式有异曲同工之妙了
    }
}
```

在**IOC特性**中 需要构建spring配置文件,用```<bean>```来直接自动创建实例,并且用``getbean()``取出实例
```xml
    <bean id = "RollDogeFactory" class="com.nanyian.factory.RolldogeFact" factory-method="getRDresult" >  
        <constructor-arg value = "1"></constructor-arg>
    </bean>
```
其中在```<bean>```中,用`factory-method="getRDresult" >`来调用工厂类中的公用静态接口,**实现对产品输出的选择**.  

主函数  
```java
public class test_factoryWithIOC {
    public static void main(String[] args) {
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-fact.xml");
        RollDoge rollDoge = (RollDoge) applicationContext.getBean("RollDogeFactory");
        System.out.println(rollDoge);
    }
}
```