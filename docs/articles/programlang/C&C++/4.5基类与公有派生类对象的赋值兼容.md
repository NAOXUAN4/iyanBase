# 4.5 基类与公有派生类对象的赋值兼容  
概括:**公有继承** 时,派生类保留了除了基类构造构造函数和析构函数之外的所有函数和成员
任何的  
#### 例:  

有基类`Animal()`
```cpp
class Animal {
protected:
    int age;

public:
    Animal(int age) : age(age) {
        cout << "Animal Constructor called." << endl;
    }

    virtual void speak() {
        cout << "Animal speaks." << endl;
    }

    int getAge() {
        return age;
    }
};
```
1. `virtual void speak() {}` 可以实现动态绑定,若无,着派生类中的同名函数若用 `Animal &a`调用,会绑定基类的成员函数.  
   


公有继承的派生类 `Dog()`
```cpp
class Dog : public Animal {
private:
    string breed;

public:
    Dog(int age, string breed) : Animal(age), breed(breed) {
        cout << "Dog Constructor called." << endl;
    }

    void speak() override {
        cout << "Dog barks." << endl;
    }

    void showBreed() {
        cout << "Breed: " << breed << endl;
    }
};
```
1. ` Dog(int age, string breed) : Animal(age), breed(breed) {}`因为共有继承不继承构造函数,因此这里需要定义`Dog()`的构造函数
2. ` void speak() override {}` 基类的`speak()` 有`virtual`属性,因此可以实现动态绑定,即可以实现`overdrive`重写.  


```cpp
int main() {
    // 创建基类对象
    Animal cat(5);
    cat.speak(); // 输出: Animal speaks.
    cout << "Cat age: " << cat.getAge() << endl; // 输出: Cat age: 5

    // 创建派生类对象
    Dog dog(3, "Labrador");
    dog.speak(); // 输出: Dog barks.
    dog.showBreed(); // 输出: Breed: Labrador
    cout << "Dog age: " << dog.getAge() << endl; // 输出: Dog age: 3

    // 多态性演示
    Animal* animalPtr = &dog;
    animalPtr->speak(); // 输出: Dog barks.

    return 0;
}
```
对于多态性演示  
```cpp
Animal* animalPtr = &dog;
```  
这里发生了一个隐式类型转换，将 `Dog* `类型转换为` Animal* `类型。这是公用继承的一个关键特性,即派生类对象可以 **隐式转换** 为基类对象。

```cpp
animalPtr->speak(); 
```
在这里发生了动态绑定。**由于 `speak() `是一个虚函数，在运行时 C++ 会根据实际对象的类型来决定调用哪个版本的 speak() 函数。** 因为 animalPtr 实际指向的是 Dog 对象，所以会调用 Dog 类中覆盖的 speak() 函数，输出 "Dog barks."。  

<br>
<br>  

#### 附:
###### "虚",虚基类和虚函数的作用(简练概括版):

1. 虚函数(Virtual Function)
虚函数的"虚"指的是函数的动态绑定。
当通过基类指针或引用调用虚函数时,实际调用的是根据对象类型确定的函数实现。
虚函数**允许在派生类中覆盖基类的虚函数实现**,实现多态性。  

2. 虚基类(Virtual Base Class)
虚基类的"虚"指的是在多重继承中避免同名基类的歧义。
当一个类继承自多个包含相同数据成员的基类时,会产生歧义。
**将这些基类声明为虚基类可以解决这一问题,确保只有一份基类的数据成员被继承。**

&emsp;总的来说:

&emsp;虚函数是实现多态性的关键,它允许在派生类中**覆盖基类的函数实现**。
&emsp;虚基类是**解决多重继承中的菱形继承问题的方法**,确保基类的数据成员只被继承一次。


