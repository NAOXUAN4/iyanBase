# 虚基类
#### 作用
1. 为了避免菱形继承问题,即`A`为`B`,`C`的基类，但是`D`多继承自`C`,`B`,又因为B，C 中可能有对于A构造函数的重载，导致内部成员值不同，使得D中的某些值不确定。

#### 例：
```cpp
#include <iostream>
using namespace std;
// 虚函数表的继承
class A {
    

    public:
        int i = 0;
        A() { std::cout << "A constructor called" << std::endl;}

        void foo() {
            std::cout << "A::foo()" << std::endl; }
};

class B : virtual public A {  //虚拟基类：无论是通过B路径还是C路径访问A的成员，都是访问的同一个实例，从而避免了重复和歧义。
    public:
        B() { std::cout << "B constructor called" << std::endl;  i += 10; cout<<"i = "<<i<<endl;}
        void foo(){
            std::cout << "B::foo()" << std::endl; }
};

class C : virtual public A {  //虚拟基类，如果基类构造过，就用同一个了，不会再次构造了
    public:
        C() { std::cout << "C constructor called" << std::endl;  i += 10; cout<<"i = "<<i<<endl;}
        void foo() { 
            std::cout << "C::foo()" << std::endl; }
};

class D : public B, public C {
    public:
        D() { std::cout << "D constructor called" << std::endl;  i += 10; cout<<"i = "<<i<<endl;}  //   i += 10; cout<<"i = "<<i<<endl; 不知道是哪个il>>菱形问题
        void callFoo() {
            C::foo();
        }
};

int main() {
    D d;
    d.callFoo();
    return 0;
}
```
#### 分析：
有基类A
```c++
class A {
    public:
        int i = 0;
        A() { std::cout << "A constructor called" << std::endl;}

        void foo() {
            std::cout << "A::foo()" << std::endl; }
};
```
A的派生类class B,class C
```cpp
class B : virtual public A {  //虚拟基类：无论是通过B路径还是C路径访问A的成员，都是访问的同一个实例，从而避免了重复和歧义。
    public:
        B() { std::cout << "B constructor called" << std::endl;  i += 10; cout<<"i = "<<i<<endl;}
        void foo(){
            std::cout << "B::foo()" << std::endl; }
};

class C : virtual public A {  //虚拟基类，如果基类构造过，就用同一个了，不会再次构造了
    public:
        C() { std::cout << "C constructor called" << std::endl;  i += 10; cout<<"i = "<<i<<endl;}
        void foo() { 
            std::cout << "C::foo()" << std::endl; }
};
```
B，C继承自虚类 使得他们的父级其实为同一个，也就是说 其中` i += 10; cout<<"i = "<<i<<endl;}`的改变，都会全局改变他们继承自的基类中A的值。  

因此，经过`B()`,`C()`两次构造函数，实际上i的值是一直在累加的，故当程序运行时,有结果
```cpp
A constructor called
B constructor called
i = 10
C constructor called
i = 20
```
即在进入构造函数```B()```,```C()```时,累加的i是同一个地址.    

同样的，当多继承的`class D` 如果未使用虚类,没有使```class B```,```class C``` 的基类指向同一片内存,```D()```中的``` cout<<"i = "<<i<<endl;``` 的i(基类的成员函数)可能产生歧义(两个i不是指向同一个内存地址的i,那么程序不知道这个'i'是派生类B父类(A的复制品)的i,还是C的)

```cpp
class D : public B, public C {
    public:
        D() { std::cout << "D constructor called" << std::endl;  i += 10; cout<<"i = "<<i<<endl;}  //   i += 10; cout<<"i = "<<i<<endl; 不知道是哪个il>>菱形问题
        void callFoo() {
            C::foo();
        }
};

int main() {
    D d;
    d.callFoo();
    return 0;
}
```
运行结果
```cpp
A constructor called
B constructor called
i = 10
C constructor called
i = 20
D constructor called
i = 30
C::foo()
```